King, on writing. Having a toolbox.
- portability
- levels
- common tools on top
- what is the most common tool?
  - what is a developers most common tool?
    - probably text editor
    - IDE?
    - compiler?
  - when King mentions his most common tool, it's 'vocabulary'
    - is a developers most common tool the knowledge of the language?
    - is it algorithms?
    - is it code patterns/architecture?
    - is it platform or library knowledge
    - is it computer science basics like computers and networking?
- "Put your vocabulary on the top shelf of yoru toolbox, and don't make any conscious effort to improve it. (YOU'LL BE DOING THAT AS YOU READ, OF COURSE...)" This quote from the book, reading to improve vocabulary. Also, people reading code to improve their coding, but what code. The code that other's wrote? Most code is not good code. It's 'working' code, it satisfies the compiler but as for a human, it's cluttered, unorganized, hodgepodge. Sometime there may have been an attempt at structure but after a while and the whole thing deteriorates into a jarbled mess. Is this the source of good 'reading' for software developers?

"use the first world that comes to your mind, if it is appropriate and colorful"
To use the right langauge in code that's appropriate. That's why naming is so important in coding. we use the first thing that comes to mind and it's usually not appropriate nor colorful. I started using unappropriate names for variables like 'x' because I usually don't determine what is the correct word for a variable until after i've assigned it and maybe even refactored it. Then the purpose of the variable becomes apparent.

His second most common tool is grammer. how would grammer relate to programming? programming structure? what are variables, conditions, loops? what is a clean implementation? recently watched a video of coding advice and one was reducing nested ifs but in the example it was more like defensive coding or fail-fast coding, get the exceptions to the norm out of the way first then create the true logic intended for the happy path. That was somewhat of a 'coding gramatical rule.' What would be other such 'gramatical' devices used in coding?

Say you don't really understand grammer (english language grammer) and you're still writing, how do you know you are doing well or not? Also, if you don't know the 'grammer' of coding, then how do you know you are doing well or not? Does anyone know the 'rules of coding grammer?' Are there any rules of coding grammer? Most of it seems to be opinion. I watched a rant on youtube how Linus Torvald was upset with some code that combined two 16 byte words into a 32 byte word. Which was the higher byte? (the need for named parameters in calls like `Assert.AreEqual(expected: x, actual: y)`) when he said `(a << 16) + b` would suffice and there was no need for another utility function. Maybe that's just style? Is grammer something the compiler is going to tell you about? if that's so then a programmer doesn't need to be concerned so much with grammer if the compiler won't accept the code.

active vs passive verbs? is there an analogy to coding? there's code that does something, then there's code that is added for other reasons. Logging, caching, validating, many ancillary tasks needed in a piece of code before one gets to the actual meat of the task. Authentication, permission, parsing (i've always thought that all coding is just a matter of taking data in one form and turning into another "at the end of the day." King might not approve of such an overused, cliche, stock phrase.) Active code would be the heart of what the developer wants to happen, the use-case, whereas the passive code would be the code needed for the application to behave well.

King advices to avoid the "passive" verbs. Would this be akin to aspect patterns? Isolate those "passive" coding needs and use them in a 'decorative' style instead of procedurally inter-sprinkeled in your code. It clutters the meaning of what you are doing. There is so much context to every method call today. You need to be concerned with all the ancillary things while focusing on the true behavior. maybe if we think of our public entry methods as the api to the user of our code, then we can consider all the things needed to accomplish the caller's needs, that black box of encapsulation but do it in an organized manner. 

Think about context. There's always context building/capturing. You must pull in from various places all the needed context to perform the task. You may say, what happens when certain paths of execution need more context, wouldn't you need to capture more context later on in your proceedure? This could really lead down a rabbit hole of using strategy patterns, functional programming techniques. Even so, even if you concider that certain data may be needed later, try to concider all the needed data up front, even if you have to hide that data behind lazy loading for the time when it's needed. What i'm trying to say is, load your context first, do all the context loading code (or lazy call code) up front, now that data is available for whatever the proceedure needs in it's journey to fulfill the caller's need. Have some 'context' object with static data and lazy load data already constructed for use.

Then there's validation. All user input will need to be validated before commencing to fulfill the core request of the user/api caller. This must be done before any true user needs happen. If you have your context data then your validation will capable of taking said data and determining whether the request can continue or error out. Again, you may need to make these decisions further down the proceedural track but also again, you can have lazy validation.

There are other concerns like logging, caching, parsing. Things like logging and caching should be decorative. We shouldn't be putting logging statements everwhere, nor should we be reinventing the wheel on caching everytime we need it. Using the decorator pattern or aspect oriented programming can reduce or hopefully eliminate the need for this type of code to creep into your true user needed code.

Then there's the case of what code gets executed based on what scenarios. All code is determined by the state of your context. When you're in Wisconsin you extract x% of payroll income tax but when you're in Washington you don't extract any payroll income tax. But maybe in Wisconsin, (I know NOTHING about payroll taxes in these states, mostly) on special holidays you don't charge payroll income tax but give a bonus instead. State machines are meant to handle these scenarios but not many programmers are versed in state machines thus you see nested if statements everywhere. These nested if statements are necessary because the context was not gathered initially and validation was not done up front. If your context is captured (even lazily) and your validation is done up front based on captured context then all you need to do is feed your context into the state machine and it's the job of the state machine to give you an implementation to execute against the parameters sent in. 

You may have one state machine for Washington, no payroll income tax, that's a null pattern. You may have multiple for Wisconsin for whatever various rules they impose. The state machine will take the context and determine what is the most appropriate implementation to execute. If Wisconsin laws change, you go to Wisconsin implementations and change them. You don't dig through 10k lines of code to find all the places needed to change.

The most important thing to keep in mind with state machines is to order your implementation selections from most complex to least. The situations with the most rules go first, those with the least, the null pattern, or the default thing to do, go last. Order is king in this matter.

Also concider that when your state machine begins to choose what implementation to give the caller there will be short circuits in every predicate that determines what it chooses. Imagine each implementation behind an ordered list of implementations and predicates, then it's just a collection. You iterate the collection until you happen among the appropriate implementation you require. State: Wisconsin, Holiday: today, etc. The most complex being on top. When the predicate is evaluated using exclusive and `&&` and ors `||` then if the most important predicate, something you have to decide when programming, in our example's case it may be the state, something you have readily available statically, no need to dynamically get this because it's probably needed for 99% of the use cases, then you can skip the predicates that don't comply and never touch the lazy data needed for those use cases.

